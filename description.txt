Pool Tournament Management App: Core Specification for Laravel Implementation
Build a backend core using Laravel (PHP framework) with MySQL as the relational database. The system manages pool tournaments for players, focusing on authentication, tournament registration with payments, match generation via a custom algorithm, results handling with confirmation, notifications, and chat. Prioritize MVP features: hierarchical (region-based) and special tournaments. Use Eloquent ORM for models, Sanctum for API auth, Echo for websockets (notifications/chat), and Cashier for payments (e.g., Stripe). Structure as APIs for future mobile integration.
Key Features (in Bullet Points)
•	User Authentication: API endpoints for signup (require community selection, store demographics) and login. Players have profiles with total_points for rankings.
•	Tournament Management: Admin creates tournaments via dashboard (name, special flag, prizes per level, charge, scope, dates, status). Users browse upcoming/ongoing, pay fee to register (add to registered_users, track payment_status).
•	Player Dashboard Data: API to fetch recent matches (last 3, expandable), top shooters (community players ordered by total_points DESC).
•	Match Participation: Players get paired, notified via websockets; per-match chat rooms; either player submits results (points), other confirms (status: pending_confirmation → completed); immutable post-confirmation; update winner_id, total_points.
•	Notifications and Chat: Websocket-based: pairing alerts, results confirmation requests, admin messages; chat_messages table for match-specific rooms.
•	Admin Controls: Web dashboard to add tournaments, monitor rounds (matches by tournament/level/round, filter incomplete), trigger initialization/next rounds in batches (e.g., per community).
•	Database Schema: Detailed below; use migrations with foreign keys (on delete cascade), indexes on tournament_id/level/round_name/status/player_ids, enums for level/status/area_scope.
•	Payments and Forfeits: Integrate Stripe for tournament_charge; if player drops, set bye_player_id, auto-winner for opponent, status='forfeit'.
•	Algorithm Integration: Service class (MatchAlgorithmService) with methods initialize($tournamentId, $level) and generateNextRound($tournamentId, $level, $groupId). Triggered by admin endpoints; writes matches to DB, broadcasts notifications.
•	Data Flow Overview: 
o	Registration: User pays → insert into registered_users (payment_status='paid', status='approved').
o	Initialization: Admin triggers → algorithm fetches approved registered_users (or winners from prior level) → groups by demographics → creates matches (insert into matches table with pending status) → broadcasts notifications.
o	Match Play/Results: One player submits the results, the other player sees the results on their interface as submitted, they can accept or reject and we will have a roll back, if the results are submitted, they cannot be changed. The status is updated to confirmed.Players submit results via API → update points/winner_id/status (pending_confirmation on submit, completed on confirm) → update players.total_points → if forfeit, auto-update.
o	Round Completion Check: Admin dashboard queries matches (WHERE tournament_id=? AND level=? AND round_name=? AND group-relevant if applicable) → count non-completed statuses (0 means ready).
o	Next Round/Level: Admin triggers generateNextRound → fetch winner_ids from completed matches → create new matches → if terminal (positions assigned), insert into winners → trigger next level init if hierarchical.
o	Winners Advancement: For next level init, query winners (WHERE tournament_id=? AND level=prior_level) → use player_ids as input players.
o	Queries for Efficiency: Use Eloquent relationships (e.g., Match belongsTo Tournament, hasMany Players); cache top shooters via jobs if needed.
Database Structure (MySQL Tables)
•	regions: id (bigint PK auto), name (varchar unique), created_at/updated_at (timestamps).
•	counties: id (bigint PK auto), region_id (bigint FK regions.id cascade), name (varchar unique per region), timestamps. Index: region_id.
•	communities: id (bigint PK auto), county_id (bigint FK counties.id cascade), region_id (bigint FK regions.id cascade, denormalized), name (varchar unique per county), timestamps. Indexes: county_id, region_id.
•	players: id (bigint PK auto), first_name/last_name/username (varchar), email (varchar unique), phone (varchar nullable), password (varchar hashed), community_id (bigint FK communities.id), county_id (bigint FK counties.id denormalized), region_id (bigint FK regions.id denormalized), total_points (int default 0), last_login (timestamp nullable), timestamps. Indexes: community_id, total_points DESC.
•	tournaments: id (bigint PK auto), name (varchar), special (tinyint default 0), county_prize/regional_prize/national_prize (decimal nullable), area_scope (enum: community,county,region,national nullable), area_name (varchar nullable), tournament_charge (decimal), start_date/end_date/registration_deadline (date nullable), status (enum: upcoming,ongoing,completed default upcoming), timestamps. Index: status.
•	registered_users: player_id (bigint FK players.id cascade), tournament_id (bigint FK tournaments.id cascade), payment_status (enum: pending,paid,failed default pending), status (enum: registered,approved,withdrawn default registered), timestamps. PK: composite (player_id, tournament_id).
•	matches: id (bigint PK auto), match_name (varchar nullable e.g. '4_player_match1'), player_1_id (bigint FK players.id), player_2_id (bigint FK players.id nullable), player_1_points/player_2_points (int nullable), winner_id (bigint FK players.id nullable), bye_player_id (bigint FK players.id nullable), level (enum: community,county,regional,national,special), round_name (varchar e.g. 'round_1'), tournament_id (bigint FK tournaments.id cascade), status (enum: pending,in_progress,pending_confirmation,completed,forfeit default pending), timestamps. Indexes: tournament_id+level+round_name+status, player_1_id, player_2_id.
•	winners: id (bigint PK auto), player_id (bigint FK players.id), position (tinyint 1-3), level (enum as above), level_id (bigint nullable e.g. community_id), tournament_id (bigint FK tournaments.id cascade), prize_awarded (tinyint default 0), timestamps. Indexes: tournament_id+level+position.
•	notifications: id (bigint PK auto), player_id (bigint FK players.id), type (enum: pairing,result,admin,other), message (text), read_at (timestamp nullable), timestamps.
•	chat_messages: id (bigint PK auto), match_id (bigint FK matches.id cascade), sender_id (bigint FK players.id), message (text), timestamps. Index: match_id.
Match Generation Algorithm Details
Implement in MatchAlgorithmService. Use randomness (mt_rand), but with checks for specificities (e.g., same-position priority, avoid same-origin). Fetch players from registered_users (initial) or winners (subsequent). Create matches with unique names, pending status. Handle forfeits as auto-completed with bye.
The algorithm will manage various aspects of the matches The algorithm will have an initialize function The initialize function will take the tournament id, and level. if the level is community level, the algorithm will collect all data of users who have registered for that tournament and group them into communities, then within the groups, the algorithm will create pairs randomly. So if in one community there are 50 players who had registered for that tournament, then we have 25 pairs. Now if in a given community there are 4 players, or players played and we have only remaining 4 players, that is previous round had 8 players and now 4 were eliminated we have four, in this case what should happen is, create two matches which we will give a unique name so that we are able to identify it, name the matches 4_player_match1 and 4_player_match2. for the two matches the winners will have a match, winner of 4_player_match1 and winner of 4_player_match2 will have a match which we will call 4_player_winners_SF and the losers will have a match 4_players_losers_SF. The loser of 4_player_losers_SF will be eliminated. the winner of the 4_player_winners_SF will be position 1 and the loser will play with the winner of 4_player_losers_SF in a match called Final which will be the final, the winner of the final match will be position 2 and the loser position 3. In the case that a community has 3 players or have narrowed down to three players meaning the previous one had 6 players and three got eliminated, we are going to have a match between player a and b in no specific order and this match will be called 3_SF, the winner of this match will be position 1 and the loser will play with the player c in a match called final and the winner of final will be position 2 and loser will be position 3. How we eliminate is that with a match which has two players, they will record their points, the one who has the highest points is the winner of that match and if its not in the special cases of 4 and 3 players then the loser is eliminated and the winner will be part of the next round. We should have a next round endpoint that receives the community id and the tournament id, it checks the winners of the previous round and makes the matches for the next round. Another scenario is where a match starts with only two players, in this case there is only one match called 2_final and the winner is position 1 and loser is position 2 and we dont have position 3, if it started with one player that player is automatically position 1. The other special case is odd numbers, if a community has 25 players at the start, then the algorithm should create 13 matches, since all players will be paired except one, the algorithm will pick one random player to play with the one who is not paired, meaning one player will play twice. If its a consecutive round not first round, like in this case where we have 13 players again, the 13 players who proceed are the winners, the one player that will not be paired, should be paired with one loser of the other 12 players that lost who should be chosen randomly, except for the case of 3 players
This method of generating next round and applying the rules will apply for all the other levels. The next level is the county level, in this level, the end point will receive the tournament id and the level which is county, for initialization, the algorithm will take all the players who won community levels, that will include position 1, 2 and 3 and their demographics including which county they belong and which community they belong. the initialization will create group the players into counties, for each county the endpoint will create matches with the rule of at least all position 1's play against themselves, position 2's play against themselves and position 3's play against themselves. The exception is when we have ad odd number of communities in that county for instance 7, in this case we will group the positions 1's to have three matches for pos 1's three matches for pos 2's and 3 matches for pos 3's, then the unpaired pos 1 and 2 will play and any random player pos 3 will play with the unpaired player. It is important to make sure at start two players dont come from the same community, Then after the first matches will have had 21 players, the groupings for next round of the county, can also try to play players from different communities until the further end. the rukes of getting pos 1, 2 and 3 for cases of 4, 3, 2 players are as same as community level. from this level we will have position 1, 2 and 3 from county level. The next level is the regional level, for this level the initialization will take the winners from all counties and the data about their demographics and will gorup them into regions. then using the same rules for county level having the pos 1's, 2's and 3's play and in this case we are looking at the county not community will apply. The players will play until we have position 1, 2 and 3 for each region. The rules of odd numbers apply and also 4, 3, and 2 players at the end also apply. and also generating next round the next level is the country level, in this level the algorithm will have an initialization that will take the winners from all regions, this time it will not group them but when generating initial matches it will try to get pos 1's, 2's and 3's play against themsevles and in net rounds try to place the players of diferent communities in pairs, the rules of next round and odd numbers, and 4, 3, and 2 players will apply.
There is a special type of tournament which will not be played with these levels, and will be stored in the database as special, for this one, the algorithm will pick all the players that registered for it, and create the first matches as pairs with the rules of odd number applying, the next round will be generated until the 4, 3 cases where we will be having the sf and finals matches. Good to note that in the 4 case will have 5 matches to completion and in three case we will have only two matches

For Hierarchical (Region-Based) Tournaments:
•	Levels: community → county → regional → national (stop early if scoped, query tournaments.area_scope).
•	Initialization ($tournamentId, $level): 
o	Fetch eligible players: Approved registered_users for community; winners.player_id (positions 1-3) from prior level for others (query winners WHERE tournament_id=? AND level=prior).
o	Group by demographics: level_id from winners or players table (community_id for community, county_id for county, etc.).
o	For each group: 
	If 1 player: Insert into winners (position=1, level_id=group_id).
	If 2: Create '2_final' match; on completion (post-results), insert winners (1/2).
	If 3: Create '3_SF' (shuffle, pair two); post-results, create 'final'; assign positions.
	If 4: Create '4_player_match1/2' (shuffle, pair); post-results, create SFs/final; assign.
	If >4: For community: Shuffle all, pair sequentially. For county/regional/national: Group by position (query winners.position), shuffle within each (1s,2s,3s), pair same-position first. If odd per position (e.g., 7 communities → 7 pos1s: 3 pairs +1 unpaired), cross-pair unpaired (unpaired pos1 vs unpaired pos2, etc.); if still odd, random cross. Avoid same-origin: At county, check players.community_id, re-shuffle/swap if same-community pair exists and alternatives available (e.g., sort by community_id, alternate pairings). At regional: Avoid same-county_id; national: Avoid same-region_id. For odds overall: Pair most, unpaired vs random prior loser (filler match, only winner advances).
o	Set round_name='round_1' or specials; insert matches; broadcast.
•	Next Round ($tournamentId, $level, $groupId): 
o	Read/Check Completion: Query matches (WHERE tournament_id=? AND level=? AND round_name=current AND (level_id relevant via joins if grouped)) → GROUP BY status, count non-'completed'/'forfeit' ==0 to proceed.
o	Fetch winners: Collect winner_id from matches (JOIN if needed).
o	If <=4: Apply special cases, assign to winners table.
o	Else: Pair as init (same-position priority if new level, but within-round: Shuffle with avoid-same-origin checks – sort by origin, pair diverse first, fallback random). Handle odds as above. Increment round_name.
o	For next level: After group positions assigned, admin triggers init for next (e.g., county after all communities complete).
For Special Tournaments:
•	Flat, level='special', no groups/positions-priority/avoid-origin (pure random shuffle).
•	Initialization ($tournamentId, 'special'): 
o	Fetch all approved registered_users.
o	Apply same <=4 specials or >4 pairs (with odds) as hierarchical.
•	Next Round ($tournamentId, 'special'): 
o	Check completion as above (no groupId).
o	Fetch winners, apply specials if <=4 (assign overall positions, level_id=null), else pair random, increment round.

